<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="Project Team"><meta name="description" content="Integration of Matter.js and Babylon.js"><title>Source: core/simulation.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">Matter.js + Babylon.js Integration</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-core_historyManager.html">core/historyManager</a></div><div class="sidebar-section-children"><a href="module-core_interactionManager.html">core/interactionManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_configManager.html">core/interactions/configManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_dragManager.html">core/interactions/dragManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_inputManager.html">core/interactions/inputManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_placementManager.html">core/interactions/placementManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_pointerManager.html">core/interactions/pointerManager</a></div><div class="sidebar-section-children"><a href="module-core_physicsManager.html">core/physicsManager</a></div><div class="sidebar-section-children"><a href="module-core_postProcess_bloom.html">core/postProcess/bloom</a></div><div class="sidebar-section-children"><a href="module-core_sceneManager.html">core/sceneManager</a></div><div class="sidebar-section-children"><a href="module-core_simulation.html">core/simulation</a></div><div class="sidebar-section-children"><a href="module-core_soundManager.html">core/soundManager</a></div><div class="sidebar-section-children"><a href="module-core_ui_briefingPanel.html">core/ui/briefingPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_configPanel.html">core/ui/configPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_hintPanel.html">core/ui/hintPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_inventoryPanel.html">core/ui/inventoryPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_menuBar.html">core/ui/menuBar</a></div><div class="sidebar-section-children"><a href="module-core_ui_objectPreview.html">core/ui/objectPreview</a></div><div class="sidebar-section-children"><a href="module-core_ui_objectivesPanel.html">core/ui/objectivesPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_trashCan.html">core/ui/trashCan</a></div><div class="sidebar-section-children"><a href="module-core_ui_uiCore.html">core/ui/uiCore</a></div><div class="sidebar-section-children"><a href="module-core_uiManager.html">core/uiManager</a></div><div class="sidebar-section-children"><a href="module-index.html">index</a></div><div class="sidebar-section-children"><a href="module-musicPlayer.html">musicPlayer</a></div><div class="sidebar-section-children"><a href="module-utils_configLoader.html">utils/configLoader</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="Condition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="LeaveZoneEndCondition.html">LeaveZoneEndCondition</a></div><div class="sidebar-section-children"><a href="LeaveZoneEndCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="LeaveZoneObjective.html">LeaveZoneObjective</a></div><div class="sidebar-section-children"><a href="LeaveZoneObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="MaxHeightEndCondition.html">MaxHeightEndCondition</a></div><div class="sidebar-section-children"><a href="MaxHeightEndCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="MaxHeightEndCondition_MaxHeightEndCondition.html">MaxHeightEndCondition</a></div><div class="sidebar-section-children"><a href="MaxHeightObjective.html">MaxHeightObjective</a></div><div class="sidebar-section-children"><a href="MaxHeightObjective_MaxHeightObjective.html">MaxHeightObjective</a></div><div class="sidebar-section-children"><a href="MaxHeightObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="MinHeightObjective.html">MinHeightObjective</a></div><div class="sidebar-section-children"><a href="MinHeightObjective_MinHeightObjective.html">MinHeightObjective</a></div><div class="sidebar-section-children"><a href="MinHeightObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="Objective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="StayInZoneEndCondition.html">StayInZoneEndCondition</a></div><div class="sidebar-section-children"><a href="StayInZoneEndCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="StayInZoneEndCondition_StayInZoneEndCondition.html">StayInZoneEndCondition</a></div><div class="sidebar-section-children"><a href="StayInZoneObjective.html">StayInZoneObjective</a></div><div class="sidebar-section-children"><a href="StayInZoneObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="StayInZoneObjective_StayInZoneObjective.html">StayInZoneObjective</a></div><div class="sidebar-section-children"><a href="TimeLimitCondition.html">TimeLimitCondition</a></div><div class="sidebar-section-children"><a href="TimeLimitCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="TimeLimitCondition_TimeLimitCondition.html">TimeLimitCondition</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-global"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#createEndMenu">createEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#createLevelSelectMenu">createLevelSelectMenu</a></div><div class="sidebar-section-children"><a href="global.html#createMainMenu">createMainMenu</a></div><div class="sidebar-section-children"><a href="global.html#disposeEndMenu">disposeEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#hideEndMenu">hideEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#hideLevelSelectMenu">hideLevelSelectMenu</a></div><div class="sidebar-section-children"><a href="global.html#hideMainMenu">hideMainMenu</a></div><div class="sidebar-section-children"><a href="global.html#showEndMenu">showEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#showLevelSelectMenu">showLevelSelectMenu</a></div><div class="sidebar-section-children"><a href="global.html#showMainMenu">showMainMenu</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"><div class="navbar-item"><a id="" href="#" target="_blank">GitHub</a></div></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">core_simulation.js</h1></header><article><pre class="prettyprint source lang-js"><code>/**
 * @module core/simulation
 * @description Manages the main simulation lifecycle, including initialization,
 * mode transitions (construction, simulation, configuration), physics updates,
 * mesh synchronization, UI integration, objective and condition handling,
 * and level progression. It serves as the central coordinator for various
 * sub-modules like physics, scene rendering, UI, and interactions.
 */
import * as BABYLON from '@babylonjs/core';
import * as Matter from 'matter-js';

import { initializeBabylon, createMeshes, updateMeshes, updateConstraintLines, disposeMeshes, attachPointerObservable, getScene, setSimulationMeshesActive, getEngine as getBabylonEngine, enableCameraControls, disableCameraControls, syncMeshesWithConfig } from './sceneManager.js';

import { initializePhysics, createPhysicsObjects, cleanupPhysics, updatePhysics, getPhysicsEngine, checkPlacementCollision, setSimulationBoundariesActive } from './physicsManager.js';

import { attachKeyboardListener, attachPointerListener, updateDragConstraintTarget, setInteractionMode, getInteractionMode, showPlacementPreview, hidePlacementPreview, startDragOnNewBody, clearConfigSelectionHighlight } from './interactionManager.js';

import { 
    createInventoryUI, disposeUI, createTrashCan, createTopMenuBar,
    updateTopMenuBar, createConfigPanel, showConfigPanel, hideConfigPanel,
    createObjectivesPanel, updateObjectivesPanel, updateUIContent,
    createEndMenu, showEndMenu, hideEndMenu,
    createBriefingPanel, showBriefingPanel,
    createHintPanel
} from './uiManager.js';
import { createMainMenu, showMainMenu, hideMainMenu } from './ui/mainMenu.js';
import { hideLevelSelectMenu, levelFiles } from './ui/levelSelectMenu.js';

import { MaxHeightObjective } from './objectives/MaxHeightObjective.js';
import { MinHeightObjective } from './objectives/MinHeightObjective.js';
import { StayInZoneObjective } from './objectives/StayInZoneObjective.js';
import { LeaveZoneObjective } from './objectives/LeaveZoneObjective.js';
import * as HistoryManager from './historyManager.js';
import { createSettingsMenu, hideSettingsMenu } from './ui/settingsMenuBabylon.js';

import { TimeLimitCondition } from './conditions/TimeLimitCondition.js';
import { StayInZoneEndCondition } from './conditions/StayInZoneEndCondition.js';
import { LeaveZoneEndCondition } from './conditions/LeaveZoneEndCondition.js';
import { MaxHeightEndCondition } from './conditions/MaxHeightEndCondition.js';

/** @type {object | null} The current level configuration object. */
let currentConfig = null;
/** @type {string | null} The path to the current level configuration file. */
let currentScenePath = null;
/** @type {string} The current application mode (e.g., 'construction', 'simulation', 'configuration'). */
let applicationMode = 'construction';
/** @type {string} The application mode before the current 'simulation' mode was entered. */
let previousApplicationMode = 'construction';
/** @type {boolean} Flag indicating if an object is currently being dragged, especially during paused states. */
let isDraggingInPause = false;
/** @type {object | null} The inventory item configuration selected for placement. */
let itemToPlace = null;
/** @type {number} Counter to generate unique IDs for newly placed items. */
let nextItemIdCounter = 0;
/** @type {boolean} Flag indicating if the user has closed the briefing panel for the current level. */
let briefingHasBeenClosedByUser = false;

/** @const {number} Timestep for physics updates when the simulation is running normally. */
const RUNNING_TIMESTEP = 1000 / 30;
/** @const {number} Timestep for physics updates when an object is being dragged (can be different if needed). */
const DRAGGING_TIMESTEP = RUNNING_TIMESTEP;

/** @const {number} Number of sub-steps for physics updates during normal simulation. */
const RUNNING_SUBSTEPS = 100;
/** @const {number} Number of sub-steps for physics updates during dragging. */
const DRAGGING_SUBSTEPS = 100;

/** @const {number} Minimum number of sub-steps per frame for physics updates. */
const MINIMUM_SUBSTEPS = 1;
/** @const {number} Maximum number of sub-steps per frame for physics updates. */
const MAXIMUM_SUBSTEPS = 400;

/** @type {number} The duration of the last physics simulation step in milliseconds. */
let lastSimulationTime = 0;

/** @type {Map&lt;string, Matter.Body>} Map of object configIds to their Matter.js Bodies. */
let bodies = new Map();
/** @type {Map&lt;string, BABYLON.Mesh>} Map of object configIds to their Babylon.js Meshes. */
let meshes = new Map();
/** @type {Map&lt;number, BABYLON.LinesMesh>} Map of constraint indices to their Babylon.js LinesMeshes. */
let constraintLines = new Map();
/** @type {Array&lt;Objective>} Array of active objectives for the current level. */
let activeObjectives = [];
/** @type {Array&lt;Condition>} Array of active end conditions for the current level. */
let activeConditions = [];
/** @type {boolean} Flag indicating if the current level has ended. */
let levelEnded = false;
/** @type {number} Total time elapsed in simulation mode for the current run, in seconds. */
let totalSimulationTimeElapsed = 0;

/**
 * Handles errors during item preview (e.g., if the preview URL is empty or invalid)
 * by reloading the current simulation. This typically occurs if the inventory item
 * configuration is problematic.
 */
function handlePreviewErrorReload() {
    initSimulation(currentConfig, currentScenePath, true); 
}

/**
 * Initializes or re-initializes the simulation with a given configuration.
 * Sets up physics, Babylon.js scene, UI elements, objectives, and conditions.
 * Can be used for initial level loading or for reloading after changes (e.g., item placement/removal).
 * @param {object} config - The level configuration object.
 * @param {string} path - The path to the current level configuration file (used for saving/loading).
 * @param {boolean} [isRestoringOrReloading=false] - Flag indicating if this is a reload/restore operation.
 *                                                 If true, some initialization steps might be skipped or handled differently
 *                                                 (e.g., mesh synchronization instead of full recreation, history not cleared).
 */
function initSimulation(config, path, isRestoringOrReloading = false) {
    if (!isRestoringOrReloading) {
        HistoryManager.clearHistory();
        briefingHasBeenClosedByUser = false;
    }
    currentConfig = config;
    currentScenePath = path;
    applicationMode = 'construction';
    levelEnded = false;

    if (typeof hideMainMenu === 'function') hideMainMenu();
    if (typeof hideLevelSelectMenu === 'function') hideLevelSelectMenu();
    if (typeof hideSettingsMenu === 'function') hideSettingsMenu();
    if (typeof hideEndMenu === 'function') hideEndMenu();

    disposeUI();
    initializeBabylon(currentConfig, isRestoringOrReloading);
    enableCameraControls();
    initializePhysics(currentConfig.world);
    populateSimulation(isRestoringOrReloading);
    attachKeyboardListener();
    attachPointerListener(handlePointerInteraction);

    createInventoryUI(currentConfig, handleAddItemRequest, handlePreviewErrorReload);
    createTopMenuBar(applicationMode, setApplicationMode);
    createTrashCan();
    createConfigPanel(handleConfigUpdate);
    
    const scene = getScene();
    if (scene) {
        createSettingsMenu(scene); 
    } else {
        console.error("Cannot create settings menu: Scene not available.");
    }

    initializeObjectives(currentConfig.objectives);
    initializeConditions(currentConfig.endConditions); 

    if (typeof createEndMenu === 'function') {
        createEndMenu(handleRestartLevel);
    } else {
        console.error("createEndMenu function is not available in simulation.js. Check imports from uiManager.");
    }

    createObjectivesPanel(activeObjectives, activeConditions);

    if (currentConfig.briefingImage) {
        createBriefingPanel(currentConfig.briefingImage, () => {
            briefingHasBeenClosedByUser = true;
        });
        if (!briefingHasBeenClosedByUser) {
            showBriefingPanel();
        }
    }

    if (currentConfig.hintImagePath) {
        createHintPanel(currentConfig.hintImagePath, () => {
        });
    }

    if (scene) {
        scene.executeWhenReady(() => {
            updateUIContent(currentConfig);
        });
    } else {
        console.error("Scene not available to schedule initial UI update.");
    }

    setSimulationBoundariesActive(false);
    setSimulationMeshesActive(false);

    if (scene) {
        scene.onBeforeRenderObservable.clear();
        scene.onBeforeRenderObservable.add(simulationLoop);
    } else {
        console.error("Failed to register simulation loop: Babylon scene not available.");
    }

    if (!isRestoringOrReloading) {
        HistoryManager.pushState(currentConfig); 
    }
}

/**
 * Handles pointer (mouse/touch) interactions within the simulation, primarily for item placement.
 * If in 'place' mode and a valid placement location is clicked, it attempts to place the selected item.
 * @param {BABYLON.PointerInfo} pointerInfo - Information about the pointer event.
 * @param {BABYLON.Vector3} worldCoords - The world coordinates of the pointer event.
 */
function handlePointerInteraction(pointerInfo, worldCoords) {
    const currentMode = getInteractionMode();

    if (currentMode !== 'place' || pointerInfo.type !== BABYLON.PointerEventTypes.POINTERDOWN || pointerInfo.event.button !== 0 || !worldCoords || !itemToPlace) {
        return;
    }

    const wb = currentConfig?.world?.workingBounds;
    if (!wb) {
        console.error("Working bounds not defined in world config!");
        cancelPlacement();
        return;
    }
    if (worldCoords.x &lt; wb.x || worldCoords.x > wb.x + wb.width ||
        worldCoords.y &lt; wb.y || worldCoords.y > wb.y + wb.height) {
        console.warn("Placement prevented: Outside working bounds.");
        cancelPlacement();
        return;
    }

    const collisionDetected = checkPlacementCollision(itemToPlace.objectProperties, worldCoords);
    if (collisionDetected) {
        console.warn("Placement prevented: Collision detected at target location.");
        cancelPlacement();
    } else {
        hidePlacementPreview();
        handlePlaceItem(worldCoords, itemToPlace);
        itemToPlace = null;
    }
}

/**
 * Cancels the current item placement operation.
 * Hides the placement preview and reverts the interaction mode to 'drag'.
 */
function cancelPlacement() {
    if (getInteractionMode() === 'place') {
        itemToPlace = null;
        hidePlacementPreview();
        setInteractionMode('drag');
    }
}

/**
 * Initiates an item placement request from the inventory.
 * Sets the application mode to 'construction', displays a placement preview for the selected item,
 * and sets the interaction mode to 'place'.
 * @param {object} inventoryItem - The inventory item configuration to be placed.
 * @param {string} inventoryItem.id - The base ID of the item.
 * @param {number} inventoryItem.count - The number of this item available in inventory.
 * @param {object} inventoryItem.objectProperties - The properties of the object to be created.
 */
function handleAddItemRequest(inventoryItem) {
    setApplicationMode('construction');

    if (getInteractionMode() === 'place') {
        return;
    }
    if (!inventoryItem || inventoryItem.count &lt;= 0) {
        console.warn(`Cannot add item: Invalid item or count is zero.`);
        return;
    }

    itemToPlace = inventoryItem;
    showPlacementPreview(inventoryItem.objectProperties);
}

/**
 * Finalizes the placement of an item at the specified world coordinates.
 * Decrements the item count in the inventory, creates the physical body and visual mesh
 * for the new object, adds it to the simulation, and saves the updated configuration.
 * @param {BABYLON.Vector3} position - The world coordinates where the item will be placed.
 * @param {object} inventoryItem - The inventory item configuration that was selected for placement.
 */
function handlePlaceItem(position, inventoryItem) {
    if (!currentConfig || !inventoryItem) return;

    HistoryManager.pushState(currentConfig); 

    const invItem = currentConfig.inventory.find(i => i.id === inventoryItem.id);
    if (!invItem || invItem.count &lt;= 0) {
        console.error(`Cannot place item ${inventoryItem.id}: not found or zero count.`);
        setInteractionMode('drag');
        return;
    }

    invItem.count--;

    let newObjectId;
    let currentSuffixToTry = nextItemIdCounter;
    const baseId = inventoryItem.id;
    const existingIds = new Set(currentConfig.objects.map(obj => obj.id));

    while (true) {
        newObjectId = `${baseId}_${currentSuffixToTry}`;
        if (!existingIds.has(newObjectId)) {
            break;
        }
        currentSuffixToTry++;
    }
    nextItemIdCounter = currentSuffixToTry + 1;

    const newObjectConfig = {
        ...inventoryItem.objectProperties,
        id: newObjectId,
        x: position.x,
        y: position.y,
        isStatic: false,
        angle: 0
    };

    currentConfig.objects.push(newObjectConfig);

    const physicsRes = createPhysicsObjects([newObjectConfig], [], currentConfig.world);
    const body = physicsRes.bodies.get(newObjectId);
    bodies.set(newObjectId, body);

    const sceneRes = createMeshes([newObjectConfig], [], currentConfig.world);
    const mesh = sceneRes.meshes.get(newObjectId);
    meshes.set(newObjectId, mesh);

    if (currentScenePath &amp;&amp; currentConfig) {
        try {
            const storageKey = `puzzleshape_config_${currentScenePath}`;
            localStorage.setItem(storageKey, JSON.stringify(currentConfig));
        } catch (e) {
            console.warn("[handlePlaceItem] Failed to save config to localStorage:", e);
        }
    }

    setInteractionMode('drag');
    setApplicationMode('construction');
    startDragOnNewBody(body, mesh, position);
}

/**
 * Removes an object from the simulation.
 * Updates the configuration, increments the corresponding item count in the inventory (if applicable),
 * saves the configuration, and reloads the simulation.
 * @param {string} objectId - The ID of the object to be removed.
 */
function handleRemoveItem(objectId) {
    if (!currentConfig) return;
    HistoryManager.pushState(currentConfig); 

    const objectIndex = currentConfig.objects.findIndex(o => o.id === objectId);
    if (objectIndex === -1) {
        console.error(`Cannot remove object ${objectId}: Not found in config.`);
        return;
    }

    const configObject = currentConfig.objects[objectIndex];
    if (configObject.isFixed) {
        console.warn(`Attempted to remove fixed object ${objectId}. Operation cancelled.`);
        return;
    }

    currentConfig.objects.splice(objectIndex, 1)[0];

    const inventoryIdMatch = objectId.match(/^([a-zA-Z0-9_]+?)_\d+$/);
    if (inventoryIdMatch) {
        const baseInventoryId = inventoryIdMatch[1];
        const itemInInventory = currentConfig.inventory.find(i => i.id === baseInventoryId);
        if (itemInInventory) {
            itemInInventory.count++;
        } else {
             console.warn(`Removed object ${objectId} looked like an inventory item, but base ID ${baseInventoryId} not found in inventory.`);
        }
    }

    if (currentScenePath &amp;&amp; currentConfig) {
        try {
            const storageKey = `puzzleshape_config_${currentScenePath}`;
            localStorage.setItem(storageKey, JSON.stringify(currentConfig));
        } catch (e) {
            console.warn("[handleRemoveItem] Failed to save config to localStorage:", e);
        }
    }

    initSimulation(currentConfig, currentScenePath, true); 
}

/**
 * Populates the simulation with physical bodies and visual meshes based on the current configuration.
 * This function is called during `initSimulation`. If `isRestoringOrReloading` is true,
 * it attempts to synchronize existing meshes with the configuration rather than recreating them all.
 * @param {boolean} [isRestoringOrReloading=false] - Flag indicating if this is a reload/restore operation.
 */
function populateSimulation(isRestoringOrReloading = false) {
    cleanupPhysics();
    initializePhysics(currentConfig.world);

    const physicsResult = createPhysicsObjects(currentConfig.objects, currentConfig.constraints, currentConfig.world);
    bodies = physicsResult.bodies;

    if (isRestoringOrReloading) {
        const { meshes: updatedMeshes, constraintLines: updatedConstraintLines } = syncMeshesWithConfig(
            currentConfig.objects,
            currentConfig.constraints,
            currentConfig.world,
            meshes,
            constraintLines
        );
        meshes = updatedMeshes;
        constraintLines = updatedConstraintLines;
    } else {
        disposeMeshes(meshes, constraintLines);
        const sceneResult = createMeshes(currentConfig.objects, currentConfig.constraints, currentConfig.world);
        meshes = sceneResult.meshes;
        constraintLines = sceneResult.constraintLines;
    }
}

/**
 * The main simulation loop, executed on every frame.
 * Updates physics, synchronizes meshes, and manages game logic like objectives and conditions
 * based on the current application mode.
 */
function simulationLoop() {
    if (!currentConfig) {
        return;
    }

    if (isDraggingInPause) {
        updateDragConstraintTarget();
    }

    const simStartTime = performance.now();

    if (applicationMode === 'simulation') {
        const subStepDelta = RUNNING_TIMESTEP / RUNNING_SUBSTEPS;
        let step = DRAGGING_SUBSTEPS * getScene().getAnimationRatio();
        step = Math.max(step, MINIMUM_SUBSTEPS);
        step = Math.min(step, MAXIMUM_SUBSTEPS);
        for (let i = 0; i &lt; step; i++) {
            updatePhysics(subStepDelta);
        }
    } else if (isDraggingInPause &amp;&amp; (applicationMode === 'construction' || applicationMode === 'configuration')) {
        const subStepDelta = DRAGGING_TIMESTEP / DRAGGING_SUBSTEPS;
        let step = DRAGGING_SUBSTEPS * getScene().getAnimationRatio();
        step = Math.max(step, MINIMUM_SUBSTEPS);
        step = Math.min(step, MAXIMUM_SUBSTEPS);
         for (let i = 0; i &lt; step; i++) {
            updatePhysics(subStepDelta);
        }
    }

    lastSimulationTime = performance.now() - simStartTime;

    updateMeshes(meshes, bodies);
    updateConstraintLines(constraintLines, currentConfig.constraints, bodies);

    if (applicationMode === 'simulation' &amp;&amp; !levelEnded) {
        const deltaTime = getBabylonEngine().getDeltaTime() / 1000; 
        totalSimulationTimeElapsed += deltaTime;

        if (activeObjectives.length > 0) {
            activeObjectives.forEach(objective => {
                if (!objective.isComplete &amp;&amp; !objective.isFailed) { 
                    objective.update(bodies, deltaTime, totalSimulationTimeElapsed);
                }
            });
        }

        if (activeConditions.length > 0) {
            activeConditions.forEach(condition => {
                if (!condition.isMet) { 
                    condition.update(bodies, activeObjectives, deltaTime);
                }
            });
        }
        
        if (activeObjectives.length > 0 || activeConditions.length > 0) {
            updateObjectivesPanel(activeObjectives, activeConditions);
        }

        if (activeConditions.length > 0) {
            for (const condition of activeConditions) {
                if (condition.isMet) {
                    triggerLevelEnd(condition);
                    break; 
                }
            }
        }
    }
}

/**
 * Gets the current application mode.
 * @returns {string} The current application mode (e.g., 'construction', 'simulation').
 */
function getApplicationMode() {
    return applicationMode;
}

/**
 * Sets the current application mode (e.g., 'construction', 'simulation', 'configuration').
 * Manages UI updates, interaction mode changes, and simulation state transitions
 * associated with switching modes.
 * @param {string} newMode - The new application mode to set.
 */
function setApplicationMode(newMode) {
    if (newMode === applicationMode) return;

    const previousMode = applicationMode;
    applicationMode = newMode;

    updateTopMenuBar(applicationMode);

    if (previousMode === 'construction' &amp;&amp; newMode !== 'construction') {
        cancelPlacement();
    }
    if (previousMode === 'configuration' &amp;&amp; newMode !== 'configuration') {
        hideConfigPanel();
        clearConfigSelectionHighlight();
    }

    if (newMode === 'simulation') {
        isDraggingInPause = false;
        setInteractionMode('drag');
        setSimulationBoundariesActive(true);
        setSimulationMeshesActive(true);
        totalSimulationTimeElapsed = 0;
        if (activeConditions.length > 0) {
            activeConditions.forEach(condition => condition.reset());
        }
        if (activeObjectives.length > 0) {
            activeObjectives.forEach(objective => objective.reset());
        }
        if (typeof hideEndMenu === 'function') {
            hideEndMenu();
        } else {
            console.error("hideEndMenu function is not available in simulation.js. Check imports from uiManager.");
        }
        if (activeObjectives.length > 0 || activeConditions.length > 0) {
            updateObjectivesPanel(activeObjectives, activeConditions);
        }

    } else if (previousMode === 'simulation' &amp;&amp; (newMode === 'construction' || newMode === 'configuration')) {
        setSimulationBoundariesActive(false);
        setSimulationMeshesActive(false);
        bodies.forEach(body => {
            if (body &amp;&amp; !body.isStatic &amp;&amp; body.initialConfig) {
                Matter.Body.setPosition(body, body.initialConfig.position);
                Matter.Body.setAngle(body, body.initialConfig.angle);
                Matter.Body.setVelocity(body, { x: 0, y: 0 });
                Matter.Body.setAngularVelocity(body, 0);
            }
        });
        if (activeObjectives.length > 0 || activeConditions.length > 0) { 
            activeObjectives.forEach(objective => objective.reset());
            updateObjectivesPanel(activeObjectives, activeConditions); 
        }
    }

    // No specific console log needed for entering configuration mode, handled by UI changes.
}

/**
 * Toggles the simulation mode between 'simulation' and the previous mode (construction/configuration).
 * If the level has ended and the mode is 'simulation', it restarts the level.
 */
function toggleSimulationMode() {
    if (applicationMode === 'simulation') {
        if (levelEnded) {
            handleRestartLevel();
        } else {
            setApplicationMode(previousApplicationMode); 
        }
    } else if (applicationMode === 'construction' || applicationMode === 'configuration') {
        previousApplicationMode = applicationMode; 
        setApplicationMode('simulation');
    }
}

/**
 * Updates the configuration of an object (position, angle) after an interaction (e.g., drag completion)
 * and reloads the simulation to reflect the changes.
 * Saves the updated configuration to localStorage.
 * @param {string} bodyId - The ID of the object whose configuration is to be updated.
 * @param {BABYLON.Vector3} finalPosition - The new position of the object.
 * @param {number} finalAngle - The new angle of the object.
 */
function triggerConfigUpdateAndReload(bodyId, finalPosition, finalAngle) {
    if (!currentConfig) return;
    HistoryManager.pushState(currentConfig); 

    const objectInConfig = currentConfig.objects.find(o => o.id === bodyId);
    if (!objectInConfig) {
        console.error(`Could not find object with ID ${bodyId} in config to update.`);
        return;
    }

    if (!objectInConfig.isFixed) {
        objectInConfig.x = finalPosition.x;
        objectInConfig.y = finalPosition.y;
        objectInConfig.angle = finalAngle;
    } else {
        // For fixed objects, we still reload to reset their visual position if moved by physics temporarily.
    }

    if (currentScenePath &amp;&amp; currentConfig) {
        try {
            const storageKey = `puzzleshape_config_${currentScenePath}`;
            localStorage.setItem(storageKey, JSON.stringify(currentConfig));
        } catch (e) {
            console.warn("[triggerConfigUpdateAndReload] Failed to save config to localStorage:", e);
        }
    }

    initSimulation(currentConfig, currentScenePath, true); 
}

/**
 * Sets the state indicating whether an object is currently being dragged,
 * particularly for managing physics updates during paused states.
 * @param {boolean} isDragging - True if an object is being dragged, false otherwise.
 */
function setDraggingState(isDragging) {
    isDraggingInPause = isDragging;
}

/**
 * Handles updates to an object's configurable properties (e.g., mass, friction, restitution)
 * from the configuration panel. Updates both the physics body and the stored configuration.
 * Saves the updated configuration to localStorage.
 * @param {string} objectId - The ID of the object being configured.
 * @param {string} property - The name of the property to update.
 * @param {number|string} value - The new value for the property.
 */
function handleConfigUpdate(objectId, property, value) {
    HistoryManager.pushState(currentConfig); 
    const body = bodies.get(objectId);
    const configObject = currentConfig.objects.find(o => o.id === objectId);

    if (!body || !configObject) {
        console.error(`Cannot update config for ${objectId}: Body or config object not found.`);
        return;
    }
    if (configObject.isFixed) {
        console.warn(`Attempted to update properties of fixed object ${objectId}. Operation cancelled.`);
        return;
    }
    switch (property) {
        case 'mass':
            if (value > 0) {
                Matter.Body.setMass(body, value);
                configObject.mass = value;
            } else {
                console.warn(`Attempted to set invalid mass (${value}) for ${objectId}.`);
            }
            break;
        case 'friction':
            body.friction = value;
            configObject.friction = value;
            break;
        case 'restitution':
            body.restitution = value;
            configObject.restitution = value;
            break;
        default:
            console.warn(`Unknown property update requested: ${property}`);
    }
    if (currentScenePath &amp;&amp; currentConfig) {
        try {
            const storageKey = `puzzleshape_config_${currentScenePath}`;
            localStorage.setItem(storageKey, JSON.stringify(currentConfig));
        } catch (e) {
            console.warn("[handleConfigUpdate] Failed to save config to localStorage:", e);
        }
    }
}

/**
 * Gets the time taken for the last physics simulation step.
 * @returns {number} The duration of the last simulation step in milliseconds.
 */
function getSimulationTime() {
    return lastSimulationTime;
}

/**
 * Initializes objectives based on the provided configuration.
 * Clears any existing objectives and creates new instances for each objective defined in the level config.
 * @param {Array&lt;object>} objectivesConfig - An array of objective configuration objects.
 */
function initializeObjectives(objectivesConfig) {
    if (activeObjectives &amp;&amp; activeObjectives.length > 0) {
        activeObjectives.forEach(obj => obj.dispose());
    }
    activeObjectives = [];

    if (!objectivesConfig || !Array.isArray(objectivesConfig) || objectivesConfig.length === 0) {
        return;
    }

    const scene = getScene();

    objectivesConfig.forEach(config => {
        try {
            let objectiveInstance = null;
            switch (config.type) {
                case 'maxHeight':
                    if (!scene) throw new Error("Babylon scene is not available for MaxHeightObjective.");
                    if (!currentConfig?.world) throw new Error("World config is not available for MaxHeightObjective.");
                    objectiveInstance = new MaxHeightObjective(config, scene, currentConfig.world);
                    break;
                case 'minHeight':
                    if (!scene) throw new Error("Babylon scene is not available for MinHeightObjective.");
                    if (!currentConfig?.world) throw new Error("World config is not available for MinHeightObjective.");
                    objectiveInstance = new MinHeightObjective(config, scene, currentConfig.world);
                    break;
                case 'stayInZone':
                    objectiveInstance = new StayInZoneObjective(config);
                    break;
                case 'leaveZone':
                    objectiveInstance = new LeaveZoneObjective(config);
                    break;
                default:
                    console.warn(`Unknown objective type '${config.type}' for objective id '${config.id}'. Skipping.`);
                    break;
            }
            if (objectiveInstance) {
                activeObjectives.push(objectiveInstance);
            }
        } catch (error) {
            console.error(`Failed to initialize objective (id: ${config.id}, type: ${config.type}):`, error);
        }
    });
}

/**
 * Initializes end conditions based on the provided configuration.
 * Clears any existing conditions and creates new instances for each condition defined in the level config.
 * @param {Array&lt;object>} conditionsConfig - An array of end condition configuration objects.
 */
function initializeConditions(conditionsConfig) {
    if (activeConditions &amp;&amp; activeConditions.length > 0) {
        activeConditions.forEach(cond => cond.dispose());
    }
    activeConditions = [];
    levelEnded = false; 

    if (!conditionsConfig || !Array.isArray(conditionsConfig) || conditionsConfig.length === 0) {
        return;
    }

    conditionsConfig.forEach(config => {
        try {
            let conditionInstance = null;
            switch (config.type) {
                case 'timeLimit':
                    conditionInstance = new TimeLimitCondition(config);
                    break;
                case 'stayInZoneEnd':
                    conditionInstance = new StayInZoneEndCondition(config);
                    break;
                case 'leaveZoneEnd':
                    conditionInstance = new LeaveZoneEndCondition(config);
                    break;
                case 'maxHeightEnd':
                    conditionInstance = new MaxHeightEndCondition(config);
                    break;
                default:
                    console.warn(`Unknown end condition type '${config.type}' for id '${config.id}'. Skipping.`);
                    break;
            }
            if (conditionInstance) {
                activeConditions.push(conditionInstance);
            }
        } catch (error) {
            console.error(`Failed to initialize end condition (id: ${config.id}, type: ${config.type}):`, error);
        }
    });
}

/**
 * Triggers the end of the level when a condition is met.
 * Sets the `levelEnded` flag, calculates scores/stars for objectives,
 * attempts to unlock the next level if all objectives are complete, and shows the end menu.
 * @param {object} metCondition - The condition object that triggered the level end.
 * @param {string} metCondition.displayName - The display name of the met condition.
 * @param {string} metCondition.id - The ID of the met condition.
 */
function triggerLevelEnd(metCondition) {
    if (levelEnded) return; 

    levelEnded = true;
    disableCameraControls();

    const finalSimTime = totalSimulationTimeElapsed;

    activeObjectives.forEach(obj => {
        if (typeof obj.calculateStars === 'function') {
            obj.calculateStars(finalSimTime);
        }
        if (obj.starsEarned > 0) {
            obj.isComplete = true;
        } else {
            obj.isComplete = false;
        }
    });

    const allObjectivesComplete = activeObjectives.every(obj => obj.isComplete);

    const objectivesData = activeObjectives.map(obj => obj.getStatus());

    if (allObjectivesComplete &amp;&amp; currentScenePath) {
        const currentLevelIndex = levelFiles.findIndex(file => file === currentScenePath);
        if (currentLevelIndex !== -1) {
            const unlockedLevelIndex = parseInt(localStorage.getItem('unlockedLevelIndex') || '0', 10);
            if (currentLevelIndex + 1 > unlockedLevelIndex) {
                const newUnlockedLevelIndex = currentLevelIndex + 1;
                localStorage.setItem('unlockedLevelIndex', newUnlockedLevelIndex.toString());
            }
        } else {
            console.warn(`Current scene path ${currentScenePath} not found in levelFiles array. Cannot unlock next level.`);
        }
    }

    if (typeof showEndMenu === 'function') {
        showEndMenu(objectivesData);
    } else {
        console.error("showEndMenu function is not available in simulation.js. Check imports from uiManager.");
    }
}

/**
 * Restarts the current level.
 * Hides the end menu (if visible) and re-initializes the simulation with the current configuration.
 */
function handleRestartLevel() {
    if (typeof hideEndMenu === 'function') {
        hideEndMenu();
    } else {
        console.error("hideEndMenu function is not available in simulation.js. Check imports from uiManager.");
    }
    initSimulation(currentConfig, currentScenePath, true); 
}

/**
 * Handles the manual triggering of a level end condition via UI.
 * This function is kept for potential future use or different types of manual triggers,
 * but for TimeLimitCondition, the button now calls condition.triggerManually() directly.
 * @param {string} conditionId - The ID of the condition to trigger.
 */
function handleManualLevelEndTrigger(conditionId) {
    const condition = activeConditions.find(c => c.id === conditionId);
    if (condition) {
        if (typeof condition.triggerManually === 'function') {
            condition.triggerManually();
        } else if (condition.config &amp;&amp; condition.config.awaitsManualTrigger) {
            condition.isMet = true; 
        } else {
            console.warn(`Attempted to manually trigger condition ${conditionId}, but it's not configured for manual trigger or config is missing.`);
        }
    } else {
        console.error(`Attempted to manually trigger non-existent condition ID: ${conditionId}`);
    }
}

export {
    initSimulation,
    getApplicationMode,
    setApplicationMode,
    toggleSimulationMode,
    triggerConfigUpdateAndReload,
    setDraggingState,
    handleConfigUpdate,
    bodies,
    currentConfig,
    currentScenePath, 
    cancelPlacement,
    handleRemoveItem,
    getSimulationTime,
    handleManualLevelEndTrigger,
    returnToMainMenu,
    isSimulationRunning,
};

/**
 * Disposes of the current simulation and returns to the main menu.
 */
function returnToMainMenu() {
    const scene = getScene();
    if (scene &amp;&amp; scene.onBeforeRenderObservable.hasObservers()) {
        scene.onBeforeRenderObservable.removeCallback(simulationLoop);
    }

    cleanupPhysics();
    disposeMeshes(meshes, constraintLines);
    disposeUI();

    currentConfig = null;
    currentScenePath = null;
    levelEnded = false;
    applicationMode = 'construction';
    disableCameraControls();

    const currentSceneInstance = getScene(); // Use a different name to avoid conflict with outer scope `scene`
    if (currentSceneInstance) {
        if (typeof hideLevelSelectMenu === 'function') hideLevelSelectMenu();
        if (typeof hideSettingsMenu === 'function') hideSettingsMenu();
        if (typeof hideEndMenu === 'function') hideEndMenu();
        
        showMainMenu();
        createSettingsMenu(currentSceneInstance); 
    } else {
        console.error("Babylon scene not available for recreating main menu.");
    }
}

/**
 * Checks if the simulation is currently running in an active gameplay state.
 * @returns {boolean} True if the application mode is 'simulation' and the level has not ended.
 */
function isSimulationRunning() {
    return applicationMode === 'simulation' &amp;&amp; !levelEnded;
}
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">Matter.js + Babylon.js Integration</a><div class="mobile-nav-links"><div class="navbar-item"><a id="" href="#" target="_blank">GitHub</a></div></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-core_historyManager.html">core/historyManager</a></div><div class="sidebar-section-children"><a href="module-core_interactionManager.html">core/interactionManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_configManager.html">core/interactions/configManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_dragManager.html">core/interactions/dragManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_inputManager.html">core/interactions/inputManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_placementManager.html">core/interactions/placementManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_pointerManager.html">core/interactions/pointerManager</a></div><div class="sidebar-section-children"><a href="module-core_physicsManager.html">core/physicsManager</a></div><div class="sidebar-section-children"><a href="module-core_postProcess_bloom.html">core/postProcess/bloom</a></div><div class="sidebar-section-children"><a href="module-core_sceneManager.html">core/sceneManager</a></div><div class="sidebar-section-children"><a href="module-core_simulation.html">core/simulation</a></div><div class="sidebar-section-children"><a href="module-core_soundManager.html">core/soundManager</a></div><div class="sidebar-section-children"><a href="module-core_ui_briefingPanel.html">core/ui/briefingPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_configPanel.html">core/ui/configPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_hintPanel.html">core/ui/hintPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_inventoryPanel.html">core/ui/inventoryPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_menuBar.html">core/ui/menuBar</a></div><div class="sidebar-section-children"><a href="module-core_ui_objectPreview.html">core/ui/objectPreview</a></div><div class="sidebar-section-children"><a href="module-core_ui_objectivesPanel.html">core/ui/objectivesPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_trashCan.html">core/ui/trashCan</a></div><div class="sidebar-section-children"><a href="module-core_ui_uiCore.html">core/ui/uiCore</a></div><div class="sidebar-section-children"><a href="module-core_uiManager.html">core/uiManager</a></div><div class="sidebar-section-children"><a href="module-index.html">index</a></div><div class="sidebar-section-children"><a href="module-musicPlayer.html">musicPlayer</a></div><div class="sidebar-section-children"><a href="module-utils_configLoader.html">utils/configLoader</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="Condition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="LeaveZoneEndCondition.html">LeaveZoneEndCondition</a></div><div class="sidebar-section-children"><a href="LeaveZoneEndCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="LeaveZoneObjective.html">LeaveZoneObjective</a></div><div class="sidebar-section-children"><a href="LeaveZoneObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="MaxHeightEndCondition.html">MaxHeightEndCondition</a></div><div class="sidebar-section-children"><a href="MaxHeightEndCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="MaxHeightEndCondition_MaxHeightEndCondition.html">MaxHeightEndCondition</a></div><div class="sidebar-section-children"><a href="MaxHeightObjective.html">MaxHeightObjective</a></div><div class="sidebar-section-children"><a href="MaxHeightObjective_MaxHeightObjective.html">MaxHeightObjective</a></div><div class="sidebar-section-children"><a href="MaxHeightObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="MinHeightObjective.html">MinHeightObjective</a></div><div class="sidebar-section-children"><a href="MinHeightObjective_MinHeightObjective.html">MinHeightObjective</a></div><div class="sidebar-section-children"><a href="MinHeightObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="Objective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="StayInZoneEndCondition.html">StayInZoneEndCondition</a></div><div class="sidebar-section-children"><a href="StayInZoneEndCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="StayInZoneEndCondition_StayInZoneEndCondition.html">StayInZoneEndCondition</a></div><div class="sidebar-section-children"><a href="StayInZoneObjective.html">StayInZoneObjective</a></div><div class="sidebar-section-children"><a href="StayInZoneObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="StayInZoneObjective_StayInZoneObjective.html">StayInZoneObjective</a></div><div class="sidebar-section-children"><a href="TimeLimitCondition.html">TimeLimitCondition</a></div><div class="sidebar-section-children"><a href="TimeLimitCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="TimeLimitCondition_TimeLimitCondition.html">TimeLimitCondition</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-global"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#createEndMenu">createEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#createLevelSelectMenu">createLevelSelectMenu</a></div><div class="sidebar-section-children"><a href="global.html#createMainMenu">createMainMenu</a></div><div class="sidebar-section-children"><a href="global.html#disposeEndMenu">disposeEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#hideEndMenu">hideEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#hideLevelSelectMenu">hideLevelSelectMenu</a></div><div class="sidebar-section-children"><a href="global.html#hideMainMenu">hideMainMenu</a></div><div class="sidebar-section-children"><a href="global.html#showEndMenu">showEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#showLevelSelectMenu">showLevelSelectMenu</a></div><div class="sidebar-section-children"><a href="global.html#showMainMenu">showMainMenu</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>