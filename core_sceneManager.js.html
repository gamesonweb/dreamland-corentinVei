<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="Project Team"><meta name="description" content="Integration of Matter.js and Babylon.js"><title>Source: core/sceneManager.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">Matter.js + Babylon.js Integration</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-core_historyManager.html">core/historyManager</a></div><div class="sidebar-section-children"><a href="module-core_interactionManager.html">core/interactionManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_configManager.html">core/interactions/configManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_dragManager.html">core/interactions/dragManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_inputManager.html">core/interactions/inputManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_placementManager.html">core/interactions/placementManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_pointerManager.html">core/interactions/pointerManager</a></div><div class="sidebar-section-children"><a href="module-core_physicsManager.html">core/physicsManager</a></div><div class="sidebar-section-children"><a href="module-core_postProcess_bloom.html">core/postProcess/bloom</a></div><div class="sidebar-section-children"><a href="module-core_sceneManager.html">core/sceneManager</a></div><div class="sidebar-section-children"><a href="module-core_simulation.html">core/simulation</a></div><div class="sidebar-section-children"><a href="module-core_soundManager.html">core/soundManager</a></div><div class="sidebar-section-children"><a href="module-core_ui_briefingPanel.html">core/ui/briefingPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_configPanel.html">core/ui/configPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_hintPanel.html">core/ui/hintPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_inventoryPanel.html">core/ui/inventoryPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_menuBar.html">core/ui/menuBar</a></div><div class="sidebar-section-children"><a href="module-core_ui_objectPreview.html">core/ui/objectPreview</a></div><div class="sidebar-section-children"><a href="module-core_ui_objectivesPanel.html">core/ui/objectivesPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_trashCan.html">core/ui/trashCan</a></div><div class="sidebar-section-children"><a href="module-core_ui_uiCore.html">core/ui/uiCore</a></div><div class="sidebar-section-children"><a href="module-core_uiManager.html">core/uiManager</a></div><div class="sidebar-section-children"><a href="module-index.html">index</a></div><div class="sidebar-section-children"><a href="module-musicPlayer.html">musicPlayer</a></div><div class="sidebar-section-children"><a href="module-utils_configLoader.html">utils/configLoader</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="Condition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="LeaveZoneEndCondition.html">LeaveZoneEndCondition</a></div><div class="sidebar-section-children"><a href="LeaveZoneEndCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="LeaveZoneObjective.html">LeaveZoneObjective</a></div><div class="sidebar-section-children"><a href="LeaveZoneObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="MaxHeightEndCondition.html">MaxHeightEndCondition</a></div><div class="sidebar-section-children"><a href="MaxHeightEndCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="MaxHeightEndCondition_MaxHeightEndCondition.html">MaxHeightEndCondition</a></div><div class="sidebar-section-children"><a href="MaxHeightObjective.html">MaxHeightObjective</a></div><div class="sidebar-section-children"><a href="MaxHeightObjective_MaxHeightObjective.html">MaxHeightObjective</a></div><div class="sidebar-section-children"><a href="MaxHeightObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="MinHeightObjective.html">MinHeightObjective</a></div><div class="sidebar-section-children"><a href="MinHeightObjective_MinHeightObjective.html">MinHeightObjective</a></div><div class="sidebar-section-children"><a href="MinHeightObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="Objective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="StayInZoneEndCondition.html">StayInZoneEndCondition</a></div><div class="sidebar-section-children"><a href="StayInZoneEndCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="StayInZoneEndCondition_StayInZoneEndCondition.html">StayInZoneEndCondition</a></div><div class="sidebar-section-children"><a href="StayInZoneObjective.html">StayInZoneObjective</a></div><div class="sidebar-section-children"><a href="StayInZoneObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="StayInZoneObjective_StayInZoneObjective.html">StayInZoneObjective</a></div><div class="sidebar-section-children"><a href="TimeLimitCondition.html">TimeLimitCondition</a></div><div class="sidebar-section-children"><a href="TimeLimitCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="TimeLimitCondition_TimeLimitCondition.html">TimeLimitCondition</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-global"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#createEndMenu">createEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#createLevelSelectMenu">createLevelSelectMenu</a></div><div class="sidebar-section-children"><a href="global.html#createMainMenu">createMainMenu</a></div><div class="sidebar-section-children"><a href="global.html#disposeEndMenu">disposeEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#hideEndMenu">hideEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#hideLevelSelectMenu">hideLevelSelectMenu</a></div><div class="sidebar-section-children"><a href="global.html#hideMainMenu">hideMainMenu</a></div><div class="sidebar-section-children"><a href="global.html#showEndMenu">showEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#showLevelSelectMenu">showLevelSelectMenu</a></div><div class="sidebar-section-children"><a href="global.html#showMainMenu">showMainMenu</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"><div class="navbar-item"><a id="" href="#" target="_blank">GitHub</a></div></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">core_sceneManager.js</h1></header><article><pre class="prettyprint source lang-js"><code>/**
 * @module core/sceneManager
 * @description Manages the Babylon.js scene, including engine setup, camera, lighting,
 * 3D model loading, mesh creation for physics objects and boundaries, and rendering.
 * It provides functions to initialize and update the visual representation of the simulation,
 * handle pointer events, and control camera interactions.
 */
import * as BABYLON from '@babylonjs/core';
import { SceneLoader } from '@babylonjs/core';
import '@babylonjs/loaders/glTF';
import { createBloomPostProcess } from './postProcess/bloom.js';
import { getSimulationTime } from './simulation.js';

/** @type {BABYLON.Engine | null} The Babylon.js engine instance. */
let babylonEngine = null;
/** @type {BABYLON.Scene | null} The current Babylon.js scene. */
let currentScene = null;
/** @type {BABYLON.ArcRotateCamera | null} The active camera in the scene. */
let activeCamera = null;
/** @type {HTMLCanvasElement | null} The HTML canvas element used for rendering. */
let canvas = null;
/** @type {BABYLON.ArcRotateCameraMouseWheelInput | null} Reference to the camera's mouse wheel input. */
let cameraMouseWheelInput = null;
/** @type {{working: BABYLON.Mesh[], sim: BABYLON.Mesh[]}} Stores arrays of meshes for working and simulation boundaries. */
let boundaryMeshes = { working: [], sim: [] };
/** @type {BABYLON.AbstractMesh | null} Root mesh of the loaded bedroom model. */
let bedroomModelRoot = null;
/** @const {string} Name of the root node for the 3D bedroom model. */
const bedroomModelName = "3D_Isometric_BEDROOM_root";
/** @type {any | null} Reference to the bloom post-processing effect. */
let bloomEffect = null;
/** @type {HTMLSpanElement | null} Span element to display FPS. */
let fpsCounterSpan = null;
/** @type {HTMLSpanElement | null} Span element to display frame time. */
let frameTimeSpan = null;
/** @type {HTMLSpanElement | null} Span element to display simulation time. */
let simTimeSpan = null;
/** @const {BABYLON.Color3} Default color for highlighting objects. */
const highlightColor = new BABYLON.Color3(1, 1, 0);
/** @const {BABYLON.Color3} Color for highlighting objects during a collision in placement mode. */
const collisionHighlightColor = new BABYLON.Color3(1, 0, 0);

/**
 * Initializes the Babylon.js engine and scene.
 * Sets up the main camera, lighting, a visual back wall, and the render loop.
 * Also initializes UI elements for displaying performance statistics and creates static boundary meshes.
 * This function should be called once at the beginning of the application.
 * @param {object} initialConfig - The initial world configuration.
 * @param {object} [initialConfig.world] - Configuration for the world, including bounds.
 * @param {object} [initialConfig.world.workingBounds] - Defines the primary interaction area.
 * @param {number} [initialConfig.world.workingBounds.x=0] - X-coordinate of the top-left corner of working bounds.
 * @param {number} [initialConfig.world.workingBounds.y=0] - Y-coordinate of the top-left corner of working bounds.
 * @param {number} [initialConfig.world.workingBounds.width=800] - Width of the working bounds.
 * @param {number} [initialConfig.world.workingBounds.height=600] - Height of the working bounds.
 * @param {number} [initialConfig.world.wallThickness=60] - Visual thickness for walls.
 * @param {boolean} [isRestoringOrReloading=false] - Flag to indicate if the scene is being reloaded (e.g., after object move).
 */
function initializeBabylon(initialConfig, isRestoringOrReloading = false) {
    canvas = document.getElementById("renderCanvas");
    if (!canvas) {
        console.error("Canvas element #renderCanvas not found!");
        return;
    }

    if (!babylonEngine) {
        babylonEngine = new BABYLON.Engine(canvas, true);
        currentScene = new BABYLON.Scene(babylonEngine);
        currentScene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

        babylonEngine.runRenderLoop(() => {
            if (currentScene) {
                currentScene.render();
            }
        });

        window.addEventListener("resize", () => {
            if (babylonEngine) {
                babylonEngine.resize();
            }
        });

        fpsCounterSpan = document.getElementById("fps-counter");
        frameTimeSpan = document.getElementById("frame-time");
        simTimeSpan = document.getElementById("sim-time");

        currentScene.onAfterRenderObservable.add(() => {
            if (fpsCounterSpan) {
                fpsCounterSpan.textContent = babylonEngine.getFps().toFixed(0);
            }
            if (frameTimeSpan) {
                frameTimeSpan.textContent = babylonEngine.getDeltaTime().toFixed(1);
            }
            if (simTimeSpan) {
                simTimeSpan.textContent = getSimulationTime().toFixed(1);
            }
        });
    }

    const {
        workingBounds = { x: 0, y: 0, width: 800, height: 600 },
        wallThickness = 60
    } = initialConfig.world || {};

    const cameraTarget = new BABYLON.Vector3(workingBounds.x + workingBounds.width / 2, workingBounds.y + workingBounds.height / 2, 0);

    if (!activeCamera) {
        activeCamera = new BABYLON.ArcRotateCamera(
            "camera", Math.PI / 2, Math.PI / 2.5, 1200,
            cameraTarget,
            currentScene
        );
        activeCamera.attachControl(canvas, true);
        activeCamera.inputs.removeByType("ArcRotateCameraKeyboardMoveInput");
        activeCamera.inputs.attached.pointers.buttons = [2];
        activeCamera.inputs.attached.pointers.angularSensibilityX = 0;
        activeCamera.inputs.attached.pointers.angularSensibilityY = 0;
        activeCamera.inputs.attached.pointers.axisMovement = false;
        activeCamera.inputs.attached.pointers.panningSensibility = 25;
        if (activeCamera.inputs.attached.mousewheel) {
            cameraMouseWheelInput = activeCamera.inputs.attached.mousewheel;
            cameraMouseWheelInput.wheelPrecision = 0.5;
            activeCamera.inputs.remove(cameraMouseWheelInput);
        }

        if (!bloomEffect || !isRestoringOrReloading) {
            if (bloomEffect) {
                bloomEffect.updateSettings({});
            } else {
                bloomEffect = createBloomPostProcess(currentScene, activeCamera);
            }
            currentScene.bloomEffect = bloomEffect;
        }
    } else {
        if (!isRestoringOrReloading) {
            activeCamera.setTarget(cameraTarget);
            activeCamera.alpha = Math.PI / 2;
            activeCamera.beta = Math.PI / 2.5;
            activeCamera.radius = 1200;
        }
    }

    activeCamera.lowerRadiusLimit = Math.max(workingBounds.width, workingBounds.height) * 0.2;
    activeCamera.upperRadiusLimit = Math.max(workingBounds.width, workingBounds.height) * 2.5;

    if (!currentScene.getMeshByName(bedroomModelName)) {
        SceneLoader.ImportMeshAsync("", "assets/", "3D_Isometric_BEDROOM.glb", currentScene).then((result) => {
            bedroomModelRoot = result.meshes[0];
            if (bedroomModelRoot) {
                bedroomModelRoot.name = bedroomModelName;
                bedroomModelRoot.position = new BABYLON.Vector3(+500, -650, -1000);
                bedroomModelRoot.scaling.scaleInPlace(2000);
                bedroomModelRoot.rotation = new BABYLON.Vector3(0, Math.PI / 1.5, 0);

                result.meshes.forEach(mesh => {
                    mesh.isPickable = false;
                });
            }
        }).catch((error) => {
            console.error("Error loading 3D_Isometric_BEDROOM.glb:", error);
        });
    }

    const existingHemisphericLight = currentScene.getLightByName("light");
    if (existingHemisphericLight) {
        existingHemisphericLight.dispose();
    }
    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), currentScene);
    light.intensity = 0.7;

    const existingDirectionalLight = currentScene.getLightByName("dirLight");
    if (existingDirectionalLight) {
        existingDirectionalLight.dispose();
    }
    const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), currentScene);
    dirLight.intensity = 0.5;

    _createBoundaryMeshes(initialConfig.world);
}

/**
 * Internal function to create visual meshes for working and simulation boundaries.
 * These meshes are static and created once during initialization.
 * @private
 * @param {object} worldConfig - The world configuration object.
 * @param {object} [worldConfig.workingBounds] - Defines the primary interaction area.
 * @param {object} [worldConfig.simulationBounds] - Defines the broader simulation area.
 * @param {number} [worldConfig.wallThickness=60] - Visual thickness for boundary walls.
 */
function _createBoundaryMeshes(worldConfig) {
    if (!currentScene) return;

    const newWorkingMeshes = [];
    const newSimMeshes = [];
    const allCurrentlyRequiredMeshNames = new Set();

    const {
        workingBounds = { x: 0, y: 0, width: 800, height: 600 },
        simulationBounds = { x: -100, y: -100, width: 1000, height: 800 },
        wallThickness = 60
    } = worldConfig || {};

    const textureUnitSize = 100;
    const boundaryDepth = 50;
    const rectDepth = 20;

    let baseWorkingMat = currentScene.getMaterialByName("baseWorkingBoundMat");
    if (!baseWorkingMat) {
        baseWorkingMat = new BABYLON.StandardMaterial("baseWorkingBoundMat", currentScene);
        baseWorkingMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
        const baseWorkingDiffuseTex = new BABYLON.Texture("assets/images/wood/plywood_diff_4k.jpg", currentScene);
        baseWorkingDiffuseTex.level = 1.8;
        baseWorkingMat.diffuseTexture = baseWorkingDiffuseTex;
        const baseWorkingNormalTex = new BABYLON.Texture("assets/images/wood/plywood_nor_gl_4k.jpg", currentScene);
        baseWorkingMat.bumpTexture = baseWorkingNormalTex;
        baseWorkingMat.alpha = 1;
    }

    let baseSimMat = currentScene.getMaterialByName("baseSimBoundMat");
    if (!baseSimMat) {
        baseSimMat = new BABYLON.StandardMaterial("baseSimBoundMat", currentScene);
        baseSimMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
        const baseSimDiffuseTex = new BABYLON.Texture("assets/images/wood/plywood_diff_4k.jpg", currentScene);
        baseSimDiffuseTex.level = 1.8;
        baseSimMat.diffuseTexture = baseSimDiffuseTex;
        const baseSimNormalTex = new BABYLON.Texture("assets/images/wood/plywood_nor_gl_4k.jpg", currentScene);
        baseSimMat.bumpTexture = baseSimNormalTex;
        baseSimMat.alpha = 1;
    }

    const wb = workingBounds;
    const sb = simulationBounds;

    const boundaryElementsConfig = [
        { name: 'mesh_boundary_working_ground', type: 'working', x: wb.x + wb.width / 2, y: wb.y + wb.height + wallThickness / 2, z: -boundaryDepth / 2, w: wb.width + 2 * wallThickness, h: wallThickness, depth: boundaryDepth, rotZ: 0, baseMat: baseWorkingMat, isVisible: true },
        { name: 'mesh_boundary_working_ceiling', type: 'working', x: wb.x + wb.width / 2, y: wb.y - wallThickness / 2, z: -boundaryDepth / 2, w: wb.width + 2 * wallThickness, h: wallThickness, depth: boundaryDepth, rotZ: 0, baseMat: baseWorkingMat, isVisible: true },
        { name: 'mesh_boundary_working_leftWall', type: 'working', x: wb.x - wallThickness / 2, y: wb.y + wb.height / 2, z: -boundaryDepth / 2, w: wallThickness, h: wb.height, depth: boundaryDepth, rotZ: 0, baseMat: baseWorkingMat, isVisible: true },
        { name: 'mesh_boundary_working_rightWall', type: 'working', x: wb.x + wb.width + wallThickness / 2, y: wb.y + wb.height / 2, z: -boundaryDepth / 2, w: wallThickness, h: wb.height, depth: boundaryDepth, rotZ: 0, baseMat: baseWorkingMat, isVisible: true },
        { name: 'mesh_boundary_sim_ground', type: 'sim', x: sb.x + sb.width / 2, y: sb.y + sb.height + wallThickness / 2, z: -boundaryDepth / 2, w: sb.width + 2 * wallThickness, h: wallThickness, depth: boundaryDepth, rotZ: 0, baseMat: baseSimMat, isVisible: true },
        { name: 'mesh_boundary_sim_ceiling', type: 'sim', x: sb.x + sb.width / 2, y: sb.y - wallThickness / 2, z: -boundaryDepth / 2, w: sb.width + 2 * wallThickness, h: wallThickness, depth: boundaryDepth, rotZ: 0, baseMat: baseSimMat, isVisible: true },
        { name: 'mesh_boundary_sim_leftWall', type: 'sim', x: sb.x - wallThickness / 2, y: sb.y + sb.height / 2, z: -boundaryDepth / 2, w: wallThickness, h: sb.height, depth: boundaryDepth, rotZ: 0, baseMat: baseSimMat, isVisible: true },
        { name: 'mesh_boundary_sim_rightWall', type: 'sim', x: sb.x + sb.width + wallThickness / 2, y: sb.y + sb.height / 2, z: -boundaryDepth / 2, w: wallThickness, h: sb.height, depth: boundaryDepth, rotZ: 0, baseMat: baseSimMat, isVisible: true },
    ];

    const bottomLeftOffsetX = -150;
    const bottomLeftOffsetY = 0;
    const bottomLeftRectWidth = 300;
    const bottomLeftRectHeight = 50;
    const bottomLeftRectAngle = Math.PI / 4;
    const bottomLeftRectPosY = 0;

    boundaryElementsConfig.push({
        name: 'sim_bottom_left_rectangle', type: 'sim',
        x: sb.x + bottomLeftOffsetX, y: bottomLeftRectPosY + bottomLeftOffsetY, z: -20,
        w: bottomLeftRectWidth, h: bottomLeftRectHeight, depth: rectDepth, rotZ: bottomLeftRectAngle,
        baseMat: baseSimMat, isVisible: true, isPillar: true
    });

    const bottomRightOffsetX = -bottomLeftOffsetX;
    const bottomRightOffsetY = -bottomLeftOffsetY;
    const bottomRightRectAngle = -bottomLeftRectAngle;
    const bottomRightRectPosY = 0;

    boundaryElementsConfig.push({
        name: 'sim_bottom_right_rectangle', type: 'sim',
        x: sb.x + sb.width + bottomRightOffsetX, y: bottomRightRectPosY + bottomRightOffsetY, z: -20,
        w: bottomLeftRectWidth, h: bottomLeftRectHeight, depth: rectDepth, rotZ: bottomRightRectAngle,
        baseMat: baseSimMat, isVisible: true, isPillar: true
    });

    boundaryElementsConfig.forEach(config => {
        let mesh = currentScene.getMeshByName(config.name);
        allCurrentlyRequiredMeshNames.add(config.name);
        let recreationNeeded = false;

        if (mesh &amp;&amp; !mesh.isDisposed()) {
            if (!mesh.metadata ||
                mesh.metadata.width !== config.w ||
                mesh.metadata.height !== config.h ||
                mesh.metadata.depth !== config.depth) {
                mesh.dispose();
                mesh = null;
            }
        } else if (mesh &amp;&amp; mesh.isDisposed()) {
            mesh = null;
        }

        if (!mesh) {
            mesh = BABYLON.MeshBuilder.CreateBox(config.name, { width: config.w, height: config.h, depth: config.depth }, currentScene);
            mesh.metadata = { width: config.w, height: config.h, depth: config.depth };

            mesh.position.set(config.x, config.y, config.z);
            mesh.rotation.z = config.rotZ;

            const meshMaterial = config.baseMat.clone(`${config.name}_material`);
            if (config.type === 'sim' &amp;&amp; !config.isPillar) {
                meshMaterial.diffuseColor.multiplyInPlace(new BABYLON.Color3(0.9, 0.9, 1));
            }

            if (meshMaterial.diffuseTexture &amp;&amp; meshMaterial.diffuseTexture instanceof BABYLON.Texture) {
                meshMaterial.diffuseTexture = meshMaterial.diffuseTexture.clone();
                meshMaterial.diffuseTexture.uScale = config.w / textureUnitSize;
                meshMaterial.diffuseTexture.vScale = config.h / textureUnitSize;
                meshMaterial.diffuseTexture.uOffset = Math.random();
                meshMaterial.diffuseTexture.vOffset = Math.random();
            }
            if (meshMaterial.bumpTexture &amp;&amp; meshMaterial.bumpTexture instanceof BABYLON.Texture) {
                meshMaterial.bumpTexture = meshMaterial.bumpTexture.clone();
                meshMaterial.bumpTexture.uScale = config.w / textureUnitSize;
                meshMaterial.bumpTexture.vScale = config.h / textureUnitSize;
                if (meshMaterial.diffuseTexture instanceof BABYLON.Texture) {
                    meshMaterial.bumpTexture.uOffset = meshMaterial.diffuseTexture.uOffset;
                    meshMaterial.bumpTexture.vOffset = meshMaterial.diffuseTexture.vOffset;
                }
            }
            mesh.material = meshMaterial;
            mesh.isPickable = false;
        } else {
            mesh.position.set(config.x, config.y, config.z);
            mesh.rotation.z = config.rotZ;

            const material = mesh.material;
            if (material &amp;&amp; material.diffuseTexture instanceof BABYLON.Texture) {
                material.diffuseTexture.uScale = config.w / textureUnitSize;
                material.diffuseTexture.vScale = config.h / textureUnitSize;
            }
            if (material &amp;&amp; material.bumpTexture instanceof BABYLON.Texture) {
                material.bumpTexture.uScale = config.w / textureUnitSize;
                material.bumpTexture.vScale = config.h / textureUnitSize;
            }
        }
        mesh.setEnabled(config.isVisible);

        if (config.type === 'working') {
            newWorkingMeshes.push(mesh);
        } else {
            newSimMeshes.push(mesh);
        }
    });

    const oldMeshes = [...(boundaryMeshes.working || []), ...(boundaryMeshes.sim || [])];
    oldMeshes.forEach(oldMesh => {
        if (oldMesh &amp;&amp; !oldMesh.isDisposed() &amp;&amp; !allCurrentlyRequiredMeshNames.has(oldMesh.name)) {
            oldMesh.dispose();
        }
    });

    boundaryMeshes.working = newWorkingMeshes;
    boundaryMeshes.sim = newSimMeshes;
}

/**
 * Creates Babylon.js visual meshes for dynamic objects and constraints based on their configurations.
 * Object meshes are created based on type (box, circle) and properties from `objectsConfig`.
 * Constraint lines are created as visual representations of physical constraints.
 * @param {Array&lt;object>} objectsConfig - Array of configuration objects for each dynamic object.
 * @param {Array&lt;object>} constraintsConfig - Array of configuration objects for each constraint.
 * @param {object} worldConfig - The world configuration (currently unused in this function but passed for consistency).
 * @returns {{meshes: Map&lt;string, BABYLON.Mesh>, constraintLines: Map&lt;number, BABYLON.LinesMesh>}}
 *          An object containing two maps:
 *          - `meshes`: Maps object configId to its corresponding Babylon.js Mesh.
 *          - `constraintLines`: Maps constraint index to its corresponding Babylon.js LinesMesh.
 *          Returns empty maps if the scene is not initialized.
 */
function createMeshes(objectsConfig, constraintsConfig, worldConfig) {
    if (!currentScene) return { meshes: new Map(), constraintLines: new Map() };

    const objectMeshes = new Map();
    const constraintLines = new Map();

    objectsConfig.forEach(obj => {
        if (!obj.id) return;
        let mesh;
        const material = new BABYLON.StandardMaterial(`mat-${obj.id}`, currentScene);
        material.diffuseColor = new BABYLON.Color3(obj.color?.r ?? 0.5, obj.color?.g ?? 0.5, obj.color?.b ?? 0.5);

        if (typeof obj.color?.a === 'number') {
            material.alpha = obj.color.a;
        }

        if (obj.type === "box") {
            mesh = BABYLON.MeshBuilder.CreateBox(`mesh-${obj.id}`, { width: obj.width, height: obj.height, depth: obj.depth || obj.width }, currentScene);

            if (material.alpha === 1) {
                const diffuseTexture = new BABYLON.Texture("assets/images/wood/plywood_diff_4k.jpg", currentScene);
                diffuseTexture.level = 1.8;
                material.diffuseTexture = diffuseTexture;

                const normalTexture = new BABYLON.Texture("assets/images/wood/plywood_nor_gl_4k.jpg", currentScene);
                material.bumpTexture = normalTexture;
            }

        } else if (obj.type === "circle") {
            mesh = BABYLON.MeshBuilder.CreateSphere(`mesh-${obj.id}`, { diameter: obj.radius * 2 }, currentScene);
            if (material.alpha === 1) {
                const diffuseTexture = new BABYLON.Texture("assets/images/wood/plywood_diff_4k.jpg", currentScene);
                diffuseTexture.level = 1.8;
                material.diffuseTexture = diffuseTexture;

                const normalTexture = new BABYLON.Texture("assets/images/wood/plywood_nor_gl_4k.jpg", currentScene);
                material.bumpTexture = normalTexture;
            }
        }

        if (mesh) {
            mesh.material = material;
            mesh.position = new BABYLON.Vector3(obj.x, obj.y, 0);
            mesh.rotation = new BABYLON.Vector3(0, 0, obj.angle || 0);

            if (obj.isSensor === true) {
                mesh.isPickable = false;
            }
            objectMeshes.set(obj.id, mesh);
        }
    });

    constraintsConfig.forEach((constraint, index) => {
         if (constraint.render?.visible !== false &amp;&amp; constraint.bodyA &amp;&amp; constraint.bodyB) {
             const line = BABYLON.MeshBuilder.CreateLines(`constraint-${index}`, {
                 points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()],
                 updatable: true
             }, currentScene);
             const lineMaterial = new BABYLON.StandardMaterial(`constraintMat-${index}`, currentScene);
             lineMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);
             line.material = lineMaterial;
             constraintLines.set(index, line);
         }
     });

    return { meshes: objectMeshes, constraintLines };
}

/**
 * Toggles the visibility of the working boundary meshes.
 * Simulation boundary meshes remain always visible.
 * @param {boolean} isActive - If true, simulation mode is considered active, so working boundaries are hidden.
 *                             If false, working boundaries are shown.
 */
function setSimulationMeshesActive(isActive) {
    if (!currentScene) return;

    boundaryMeshes.working.forEach(mesh => {
        if (mesh &amp;&amp; !mesh.isDisposed()) {
            mesh.setEnabled(!isActive);
        }
    });
}

/**
 * Updates the positions and rotations of dynamic object meshes to match their corresponding physics bodies.
 * Static boundary meshes are not updated by this function.
 * @param {Map&lt;string, BABYLON.Mesh>} meshes - A map of object configIds to their Babylon.js Meshes.
 * @param {Map&lt;string, Matter.Body>} bodies - A map of object configIds (or boundary labels) to their Matter.js Bodies.
 */
function updateMeshes(meshes, bodies) {
    if (!currentScene) return;
    meshes.forEach((mesh, id) => {
        const body = bodies.get(id);
        if (body &amp;&amp; mesh &amp;&amp; !mesh.isDisposed()) {
            mesh.position.x = body.position.x;
            mesh.position.y = body.position.y;
            if (!body.isStatic) {
                mesh.rotation.z = body.angle;
            }
        }
    });
}

/**
 * Updates the visual representation of constraint lines to connect the current positions of their linked bodies.
 * @param {Map&lt;number, BABYLON.LinesMesh>} lines - A map of constraint indices to their Babylon.js LinesMeshes.
 * @param {Array&lt;object>} constraintsConfig - The original array of constraint configuration objects.
 * @param {Map&lt;string, Matter.Body>} bodies - A map of object configIds to their Matter.js Bodies.
 */
function updateConstraintLines(lines, constraintsConfig, bodies) {
     if (!currentScene) return;
     lines.forEach((line, index) => {
         const constraintConfig = constraintsConfig[index];
         if (constraintConfig &amp;&amp; line &amp;&amp; !line.isDisposed()) {
             const bodyA = bodies.get(constraintConfig.bodyA);
             const bodyB = bodies.get(constraintConfig.bodyB);
             if (bodyA &amp;&amp; bodyB) {
                 const points = [
                     new BABYLON.Vector3(bodyA.position.x, bodyA.position.y, 0),
                     new BABYLON.Vector3(bodyB.position.x, bodyB.position.y, 0)
                 ];
                 BABYLON.MeshBuilder.CreateLines(line.name, { points: points, instance: line });
             }
         }
     });
 }

/**
 * Disposes of all dynamic object meshes and constraint line meshes from the scene.
 * Static boundary meshes are not disposed by this function as they are persistent.
 * @param {Map&lt;string, BABYLON.Mesh>} meshes - A map of object configIds to their Babylon.js Meshes.
 * @param {Map&lt;number, BABYLON.LinesMesh>} lines - A map of constraint indices to their Babylon.js LinesMeshes.
 */
function disposeMeshes(meshes, lines) {
    meshes.forEach(mesh => {
        if (mesh &amp;&amp; !mesh.isDisposed()) mesh.dispose();
    });

    lines.forEach(line => {
        if (line &amp;&amp; !line.isDisposed()) line.dispose();
    });
}

/**
 * Attaches an observer to the scene's pointer events.
 * @param {function(BABYLON.PointerInfo): void} callback - The function to be called when a pointer event occurs.
 *        It receives a BABYLON.PointerInfo object containing event details.
 * @returns {BABYLON.Observer&lt;BABYLON.PointerInfo> | null} The observer instance if attached successfully, otherwise null.
 */
function attachPointerObservable(callback) {
    if (currentScene) {
        return currentScene.onPointerObservable.add(callback);
    }
    return null;
}

/**
 * Gets the current Babylon.js scene instance.
 * @returns {BABYLON.Scene | null} The current scene, or null if not initialized.
 */
function getScene() {
    return currentScene;
}

/**
 * Gets the active Babylon.js camera instance.
 * @returns {BABYLON.ArcRotateCamera | null} The active camera, or null if not initialized.
 */
function getCamera() {
    return activeCamera;
}

/**
 * Gets the bloom effect instance.
 * @returns {Object | null} The bloom effect instance, or null if not initialized.
 */
function getBloomEffect() {
    return bloomEffect;
}

/**
 * Gets the HTML canvas element used for rendering.
 * @returns {HTMLCanvasElement | null} The canvas element, or null if not initialized.
 */
function getCanvas() {
    return canvas;
}

/**
 * Gets the Babylon.js engine instance.
 * @returns {BABYLON.Engine | null} The engine instance, or null if not initialized.
 */
function getEngine() {
    return babylonEngine;
}

/**
 * Highlights a given mesh by changing its diffuse color.
 * Stores and returns the original diffuse color of the mesh's material.
 * Only works for StandardMaterial or PBRMaterial.
 * @param {BABYLON.Mesh} mesh - The mesh to highlight.
 * @param {BABYLON.Color3} color - The color to apply for highlighting.
 * @returns {BABYLON.Color3 | null} The original diffuse color of the mesh if highlighting was successful, otherwise null.
 */
function highlightMesh(mesh, color) {
    if (mesh &amp;&amp; mesh.material &amp;&amp; !mesh.isDisposed()) {
        if (mesh.material instanceof BABYLON.StandardMaterial || mesh.material instanceof BABYLON.PBRMaterial) {
            const originalColor = mesh.material.diffuseColor?.clone();
            if (originalColor) {
                 mesh.material.diffuseColor = color;
                 return originalColor;
            }
        } else {
            console.warn(`Highlighting not supported for material type: ${mesh.material.getClassName()} on mesh ${mesh.name}`);
        }
    }
    return null;
}

/**
 * Restores the original diffuse color of a previously highlighted mesh.
 * Only works for StandardMaterial or PBRMaterial.
 * @param {BABYLON.Mesh} mesh - The mesh whose color is to be restored.
 * @param {BABYLON.Color3} originalColor - The original diffuse color to restore.
 */
function restoreMeshColor(mesh, originalColor) {
    if (mesh &amp;&amp; mesh.material &amp;&amp; !mesh.isDisposed() &amp;&amp; originalColor) {
         if (mesh.material instanceof BABYLON.StandardMaterial || mesh.material instanceof BABYLON.PBRMaterial) {
            mesh.material.diffuseColor = originalColor;
        }
    }
}

/**
 * Finds a Babylon.js mesh that corresponds to a given Matter.js physics body.
 * This relies on a naming convention where the mesh name is `mesh-{body.configId}`.
 * Boundary bodies do not have `configId` and will return null.
 * @param {Matter.Body} body - The Matter.js body for which to find the corresponding mesh.
 * @returns {BABYLON.Mesh | null} The Babylon.js mesh if found, otherwise null.
 */
function findMeshByBody(body) {
    if (!body || !body.configId || !currentScene) {
        if (body.label &amp;&amp; body.label.startsWith('boundary_')) return null;
        return null;
    }
    const meshName = `mesh-${body.configId}`;
    return currentScene.getMeshByName(meshName);
}

/**
 * Enables camera controls (panning, zooming).
 */
function enableCameraControls() {
    if (activeCamera &amp;&amp; canvas) {
        if (!activeCamera.inputs.isAttached) {
            activeCamera.attachControl(canvas, true);
        }
        setCameraMouseWheelZoomActive(true);
    }
}

/**
 * Disables camera controls (panning, zooming).
 */
function disableCameraControls() {
    if (activeCamera &amp;&amp; canvas &amp;&amp; activeCamera.inputs.attached.pointers) {
        activeCamera.detachControl(canvas);
    }
}

export {
    initializeBabylon,
    createMeshes,
    syncMeshesWithConfig,
    updateMeshes,
    updateConstraintLines,
    disposeMeshes,
    attachPointerObservable,
    getScene,
    getCamera,
    getBloomEffect,
    getCanvas,
    getEngine,
    highlightMesh,
    restoreMeshColor,
    highlightColor,
    collisionHighlightColor,
    findMeshByBody,
    setSimulationMeshesActive,
    enableCameraControls,
    disableCameraControls,
    setCameraMouseWheelZoomActive
};

/**
 * Activates or deactivates the camera's mouse wheel zoom functionality.
 * It manages the attachment and detachment of the mouse wheel input controller.
 * @param {boolean} isActive - True to activate mouse wheel zoom, false to deactivate.
 */
function setCameraMouseWheelZoomActive(isActive) {
    if (!activeCamera || !canvas) {
        console.warn(`SceneManager: setCameraMouseWheelZoomActive(${isActive}) - Active camera or canvas not available.`);
        return;
    }

    if (isActive) {
        if (cameraMouseWheelInput &amp;&amp; !activeCamera.inputs.attached.mousewheel) {
            activeCamera.inputs.add(cameraMouseWheelInput);
        } else if (!cameraMouseWheelInput) {
            console.warn(`SceneManager: setCameraMouseWheelZoomActive(${isActive}) - Stored cameraMouseWheelInput is null. Cannot attach.`);
        }
    } else {
        if (activeCamera.inputs.attached.mousewheel) {
            if (!cameraMouseWheelInput) {
                cameraMouseWheelInput = activeCamera.inputs.attached.mousewheel;
            }
            activeCamera.inputs.remove(activeCamera.inputs.attached.mousewheel);
        }
    }
}

/**
 * Synchronizes Babylon.js visual meshes and constraint lines with the provided configurations.
 * Updates existing meshes, creates new ones, and disposes of meshes no longer in the config.
 * @param {Array&lt;object>} objectsConfig - Array of configuration objects for each dynamic object.
 * @param {Array&lt;object>} constraintsConfig - Array of configuration objects for each constraint.
 * @param {object} worldConfig - The world configuration.
 * @param {Map&lt;string, BABYLON.Mesh>} existingObjectMeshes - Current map of object configId to its Babylon.js Mesh.
 * @param {Map&lt;number, BABYLON.LinesMesh>} existingConstraintLines - Current map of constraint index to its Babylon.js LinesMesh.
 * @returns {{meshes: Map&lt;string, BABYLON.Mesh>, constraintLines: Map&lt;number, BABYLON.LinesMesh>}}
 *          An object containing two maps:
 *          - `meshes`: The updated map of object configId to its Babylon.js Mesh.
 *          - `constraintLines`: The updated map of constraint index to its Babylon.js LinesMesh.
 */
function syncMeshesWithConfig(objectsConfig, constraintsConfig, worldConfig, existingObjectMeshes, existingConstraintLines) {
    if (!currentScene) return { meshes: new Map(), constraintLines: new Map() };

    const newObjectMeshes = new Map();
    const newConstraintLines = new Map();
    const existingMeshIds = new Set(existingObjectMeshes.keys());
    const existingConstraintIndices = new Set(existingConstraintLines.keys());

    objectsConfig.forEach(obj => {
        if (!obj.id) return;

        let mesh = existingObjectMeshes.get(obj.id);
        if (mesh) {
            if (mesh.isDisposed()) {
                mesh = null;
            } else {
                mesh.position.x = obj.x;
                mesh.position.y = obj.y;
                mesh.rotation.z = obj.angle || 0;

                if (mesh.material instanceof BABYLON.StandardMaterial) {
                    const material = mesh.material;
                    material.diffuseColor.set(obj.color?.r ?? 0.5, obj.color?.g ?? 0.5, obj.color?.b ?? 0.5);

                    let newAlpha = 1;
                    if (typeof obj.color?.a === 'number') {
                        newAlpha = obj.color.a;
                    }
                    material.alpha = newAlpha;

                    if (newAlpha === 1) {
                        if (!material.diffuseTexture) {
                            const diffuseTexture = new BABYLON.Texture("assets/images/wood/plywood_diff_4k.jpg", currentScene);
                            diffuseTexture.level = 1.8;
                            material.diffuseTexture = diffuseTexture;

                            const normalTexture = new BABYLON.Texture("assets/images/wood/plywood_nor_gl_4k.jpg", currentScene);
                            material.bumpTexture = normalTexture;
                        } else if (material.diffuseTexture instanceof BABYLON.Texture &amp;&amp; material.diffuseTexture.level !== 1.8) {
                            material.diffuseTexture.level = 1.8;
                        }
                    } else {
                        if (material.diffuseTexture) {
                            if (material.diffuseTexture.dispose) material.diffuseTexture.dispose();
                            material.diffuseTexture = null;
                        }
                        if (material.bumpTexture) {
                            if (material.bumpTexture.dispose) material.bumpTexture.dispose();
                            material.bumpTexture = null;
                        }
                    }
                }
                newObjectMeshes.set(obj.id, mesh);
                existingMeshIds.delete(obj.id);
            }
        }

        if (!mesh) {
            const material = new BABYLON.StandardMaterial(`mat-${obj.id}`, currentScene);
            material.diffuseColor = new BABYLON.Color3(obj.color?.r ?? 0.5, obj.color?.g ?? 0.5, obj.color?.b ?? 0.5);
            if (typeof obj.color?.a === 'number') {
                material.alpha = obj.color.a;
            }

            if (obj.type === "box") {
                mesh = BABYLON.MeshBuilder.CreateBox(`mesh-${obj.id}`, { width: obj.width, height: obj.height, depth: obj.depth || obj.width }, currentScene);
                if (material.alpha === 1) {
                    const diffuseTexture = new BABYLON.Texture("assets/images/wood/plywood_diff_4k.jpg", currentScene);
                    diffuseTexture.level = 0.7; // Corrected from 1.8 to 0.7 as per original logic for new meshes
                    material.diffuseTexture = diffuseTexture;

                    const normalTexture = new BABYLON.Texture("assets/images/wood/plywood_nor_gl_4k.jpg", currentScene);
                    material.bumpTexture = normalTexture;
                }

            } else if (obj.type === "circle") {
                mesh = BABYLON.MeshBuilder.CreateSphere(`mesh-${obj.id}`, { diameter: obj.radius * 2 }, currentScene);
                if (material.alpha === 1) {
                    const diffuseTexture = new BABYLON.Texture("assets/images/wood/plywood_diff_4k.jpg", currentScene);
                    diffuseTexture.level = 0.7; // Corrected from 1.8 to 0.7
                    material.diffuseTexture = diffuseTexture;

                    const normalTexture = new BABYLON.Texture("assets/images/wood/plywood_nor_gl_4k.jpg", currentScene);
                    material.bumpTexture = normalTexture;
                }
            }

            if (mesh) {
                mesh.material = material;
                mesh.position = new BABYLON.Vector3(obj.x, obj.y, 0);
                mesh.rotation = new BABYLON.Vector3(0, 0, obj.angle || 0);
                if (obj.isSensor === true) {
                    mesh.isPickable = false;
                }
                newObjectMeshes.set(obj.id, mesh);
            }
        }
    });

    existingMeshIds.forEach(idToRemove => {
        const meshToDispose = existingObjectMeshes.get(idToRemove);
        if (meshToDispose &amp;&amp; !meshToDispose.isDisposed()) {
            meshToDispose.dispose();
        }
    });

    constraintsConfig.forEach((constraint, index) => {
        let line = existingConstraintLines.get(index);

        if (constraint.render?.visible !== false &amp;&amp; constraint.bodyA &amp;&amp; constraint.bodyB) {
            if (line) {
                 if (line.isDisposed()) {
                    line = null;
                } else {
                    newConstraintLines.set(index, line);
                    existingConstraintIndices.delete(index);
                }
            }

            if (!line) {
                line = BABYLON.MeshBuilder.CreateLines(`constraint-${index}`, {
                    points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()],
                    updatable: true
                }, currentScene);
                const lineMaterial = new BABYLON.StandardMaterial(`constraintMat-${index}`, currentScene);
                lineMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);
                line.material = lineMaterial;
                newConstraintLines.set(index, line);
            }
        } else {
            if (line &amp;&amp; !line.isDisposed()) {
                line.dispose();
            }
            existingConstraintIndices.delete(index); // Ensure it's removed if not visible or invalid
        }
    });

    existingConstraintIndices.forEach(indexToRemove => {
        const lineToDispose = existingConstraintLines.get(indexToRemove);
        if (lineToDispose &amp;&amp; !lineToDispose.isDisposed()) {
            lineToDispose.dispose();
        }
    });

    return { meshes: newObjectMeshes, constraintLines: newConstraintLines };
}
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">Matter.js + Babylon.js Integration</a><div class="mobile-nav-links"><div class="navbar-item"><a id="" href="#" target="_blank">GitHub</a></div></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-core_historyManager.html">core/historyManager</a></div><div class="sidebar-section-children"><a href="module-core_interactionManager.html">core/interactionManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_configManager.html">core/interactions/configManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_dragManager.html">core/interactions/dragManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_inputManager.html">core/interactions/inputManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_placementManager.html">core/interactions/placementManager</a></div><div class="sidebar-section-children"><a href="module-core_interactions_pointerManager.html">core/interactions/pointerManager</a></div><div class="sidebar-section-children"><a href="module-core_physicsManager.html">core/physicsManager</a></div><div class="sidebar-section-children"><a href="module-core_postProcess_bloom.html">core/postProcess/bloom</a></div><div class="sidebar-section-children"><a href="module-core_sceneManager.html">core/sceneManager</a></div><div class="sidebar-section-children"><a href="module-core_simulation.html">core/simulation</a></div><div class="sidebar-section-children"><a href="module-core_soundManager.html">core/soundManager</a></div><div class="sidebar-section-children"><a href="module-core_ui_briefingPanel.html">core/ui/briefingPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_configPanel.html">core/ui/configPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_hintPanel.html">core/ui/hintPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_inventoryPanel.html">core/ui/inventoryPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_menuBar.html">core/ui/menuBar</a></div><div class="sidebar-section-children"><a href="module-core_ui_objectPreview.html">core/ui/objectPreview</a></div><div class="sidebar-section-children"><a href="module-core_ui_objectivesPanel.html">core/ui/objectivesPanel</a></div><div class="sidebar-section-children"><a href="module-core_ui_trashCan.html">core/ui/trashCan</a></div><div class="sidebar-section-children"><a href="module-core_ui_uiCore.html">core/ui/uiCore</a></div><div class="sidebar-section-children"><a href="module-core_uiManager.html">core/uiManager</a></div><div class="sidebar-section-children"><a href="module-index.html">index</a></div><div class="sidebar-section-children"><a href="module-musicPlayer.html">musicPlayer</a></div><div class="sidebar-section-children"><a href="module-utils_configLoader.html">utils/configLoader</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="Condition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="LeaveZoneEndCondition.html">LeaveZoneEndCondition</a></div><div class="sidebar-section-children"><a href="LeaveZoneEndCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="LeaveZoneObjective.html">LeaveZoneObjective</a></div><div class="sidebar-section-children"><a href="LeaveZoneObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="MaxHeightEndCondition.html">MaxHeightEndCondition</a></div><div class="sidebar-section-children"><a href="MaxHeightEndCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="MaxHeightEndCondition_MaxHeightEndCondition.html">MaxHeightEndCondition</a></div><div class="sidebar-section-children"><a href="MaxHeightObjective.html">MaxHeightObjective</a></div><div class="sidebar-section-children"><a href="MaxHeightObjective_MaxHeightObjective.html">MaxHeightObjective</a></div><div class="sidebar-section-children"><a href="MaxHeightObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="MinHeightObjective.html">MinHeightObjective</a></div><div class="sidebar-section-children"><a href="MinHeightObjective_MinHeightObjective.html">MinHeightObjective</a></div><div class="sidebar-section-children"><a href="MinHeightObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="Objective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="StayInZoneEndCondition.html">StayInZoneEndCondition</a></div><div class="sidebar-section-children"><a href="StayInZoneEndCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="StayInZoneEndCondition_StayInZoneEndCondition.html">StayInZoneEndCondition</a></div><div class="sidebar-section-children"><a href="StayInZoneObjective.html">StayInZoneObjective</a></div><div class="sidebar-section-children"><a href="StayInZoneObjective_Objective.html">Objective</a></div><div class="sidebar-section-children"><a href="StayInZoneObjective_StayInZoneObjective.html">StayInZoneObjective</a></div><div class="sidebar-section-children"><a href="TimeLimitCondition.html">TimeLimitCondition</a></div><div class="sidebar-section-children"><a href="TimeLimitCondition_Condition.html">Condition</a></div><div class="sidebar-section-children"><a href="TimeLimitCondition_TimeLimitCondition.html">TimeLimitCondition</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-global"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#createEndMenu">createEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#createLevelSelectMenu">createLevelSelectMenu</a></div><div class="sidebar-section-children"><a href="global.html#createMainMenu">createMainMenu</a></div><div class="sidebar-section-children"><a href="global.html#disposeEndMenu">disposeEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#hideEndMenu">hideEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#hideLevelSelectMenu">hideLevelSelectMenu</a></div><div class="sidebar-section-children"><a href="global.html#hideMainMenu">hideMainMenu</a></div><div class="sidebar-section-children"><a href="global.html#showEndMenu">showEndMenu</a></div><div class="sidebar-section-children"><a href="global.html#showLevelSelectMenu">showLevelSelectMenu</a></div><div class="sidebar-section-children"><a href="global.html#showMainMenu">showMainMenu</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>